package src;
import java_cup.runtime.*;
import java.util.*;

terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, ASS, ARRAYELE, STRUCTELE;
terminal           RPAREN, LPAREN, RBRACKET, LBRACKET, LESSER, GREATER, COMMA, COLON, LBRACE, RBRACE;
terminal           IF, THEN, ELSE, WHILE,  DO, BEGIN,  END;
terminal           PRINT;
terminal           EQ, NOTEQ, LESSEREQ, GREATEREQ, AND, OR, NOT;
terminal Integer   INTDEF, FLOATDEF, BOOLEANDEF, CHARDEF, ARRAYDEF, FUNCDEF, STRUCTDEF;
terminal Integer   INT;
terminal Float     FLOAT;
terminal Boolean   BOOLEAN;
terminal String    CHAR;
terminal String    ID;
terminal           ARRAY, STRUCT;

non terminal KeyValue           keyValuePart;
non terminal KeyValueList       keyValueList;
non terminal Aexp               array, expListPart;
non terminal Aexp               struct;
non terminal ExpList            expList;
non terminal Object             program;
non terminal Astat              statement, assignment, ifthen, print, while, statement_part, vardec;
non terminal Lstat              statement_list;
non terminal Aexp               expr, factor, term;
non terminal Aexp               boolExp, boolFactor, boolTerm, relation, notFactor;
non terminal Integer            type;

program         ::= statement_list:s
                    {: 
                        System.out.println("***Start of Program***");
                        s.execute(); 
                        System.out.println("***End of Program***");
                        SymbolTable.dump();
                    :};


statement_list  ::= statement_list:l statement_part:s
                    {: RESULT = new Lstat(l,s) ; :}
                |   statement_part:s
                    {: RESULT = new Lstat(s); :};

statement_part  ::= statement:s
                    {: RESULT = s; :}
                SEMI;

statement       ::= assignment:s
                    {: RESULT = s; :}
                | vardec:s
                    {: RESULT = s; :}
                | ifthen:s
                    {: RESULT = s; :}
                | print:s
                    {: RESULT = s; :}
                | while:s
                    {: RESULT = s; :}
                | BEGIN statement_list:s END
                    {: RESULT = Astat.block(s); :};

while           ::= WHILE boolExp:e DO statement:s
                    {: RESULT = Astat.whileloop(e,s); :};

print           ::= PRINT boolExp:e
                    {: RESULT = Astat.print(e); :};

ifthen          ::= IF boolExp:e THEN statement:s
                    {: RESULT = Astat.ifthen(e, s); :}
                |   IF boolExp:e THEN statement:s_if ELSE statement:s_else
                    {: RESULT = Astat.ifthenelse(e, s_if, s_else); :};

expListPart     ::= boolExp:e
                    {: RESULT = e;:}
                COMMA;
expList         ::= expList:e_list expListPart:e
                    {: RESULT =  new ExpList(e_list, e); :}
                |   expListPart:e
                    {: RESULT = new ExpList(e); :};

vardec          ::= type:t ID:i ASS boolExp:e
                    {: RESULT = Astat.declare(t, i, e); :}
                |  ARRAYDEF:a COLON boolExp:size ID:i ASS boolExp:e
                    {: RESULT = Astat.declare(a, size, i, e); :}
                |  STRUCTDEF:s ID:i ASS boolExp:e
                    {: RESULT = Astat.declare(s, i, e); :};

type            ::= INTDEF:i
                    {: RESULT = i; :}
                |  FLOATDEF:f
                    {: RESULT = f; :}
                |  BOOLEANDEF:b
                    {: RESULT = b; :}
                |  CHARDEF:c
                    {: RESULT = c; :};

keyValuePart ::= ID:i COLON boolExp:e
                        {: RESULT = new KeyValue(i, e);:} COMMA;

keyValueList    ::= keyValueList:kv_list keyValuePart:kv_part
                    {: RESULT = new KeyValueList(kv_list, kv_part); :}
                |   keyValuePart:kv_part
                    {: RESULT = new KeyValueList(kv_part); :};

assignment      ::= ID:i ASS boolExp:e
                    {: RESULT = Astat.assignment(i, e); :}
                |   ID:a LBRACKET boolExp:index RBRACKET ASS boolExp:e /* assign array element */
                    {: RESULT = Astat.assignment(a, index, e); :}
                |   ID:s MINUS GREATER ID:key ASS boolExp:e /* assign struct element */
                    {: RESULT = Astat.assignment(s, key, e); :};
boolExp         ::= boolExp:e OR boolTerm:t
                    {: RESULT = new Aexp(new Args(e, t), sym.OR); :}
                |   boolTerm:t
                    {: RESULT = t; :};
boolTerm        ::= boolTerm:t AND notFactor:f
                    {: RESULT = new Aexp(new Args(t, f), sym.AND); :}
                |   notFactor:f
                    {: RESULT = f; :};
notFactor       ::= NOT boolFactor:b
                    {: RESULT = new Aexp(new Args(b), sym.NOT); :}
                |   boolFactor:f
                    {: RESULT = f; :};
boolFactor      ::= BOOLEAN:b
                    {: RESULT = new Aexp(b); :}
                |   relation:r
                    {: RESULT = r; :};
relation        ::= expr:e0 EQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.EQ);
                    :}
                    |expr:e0 NOTEQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.NOTEQ);
                    :}
                    |expr:e0 GREATEREQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.GREATEREQ);
                    :}
                    |expr:e0 GREATER expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.GREATER);
                    :}
                    |expr:e0 LESSEREQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.LESSEREQ);
                    :}
                    |expr:e0 LESSER expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.LESSER);
                    :}
                    | expr:e
                    {: RESULT = e; :};
expr            ::= expr:e PLUS term:t
                    {: RESULT = new Aexp(new Args(e,t), sym.PLUS); :}
                | expr:e MINUS term:t
                    {: RESULT = new Aexp(new Args(e,t), sym.MINUS); :}
                | term:t
                    {: RESULT = t; :};

term            ::= term:t TIMES factor:f
                    {: RESULT = new Aexp(new Args(t,f), sym.TIMES); :}
                | term:t DIVIDE factor:f
                    {: RESULT = new Aexp(new Args(t,f), sym.DIVIDE); :}
                | factor:f
                    {: RESULT = f; :};

factor          ::= LPAREN boolExp:e RPAREN
                    {: RESULT = e; :}
                | INT:i
                    {: RESULT = new Aexp(i); :}
                | FLOAT:f
                    {: RESULT = new Aexp(f); :}
                | CHAR:c
                    {: RESULT = new Aexp(c, false); :}
                | array:a
                    {: RESULT = a; :}
                | struct:s
                    {: RESULT = s; :}
                | ID:a LBRACKET boolExp:index RBRACKET /* access array element: id[exp] */
                    {: RESULT = new Aexp(a, index); :}
                | ID:s MINUS GREATER ID:key /* access struct element: id->keyId */
                    {: RESULT = new Aexp(s, key); :}
                | ID:i
                    {: RESULT = new Aexp(i, true); :};

                   /* [a,b,c,e,]*/
array          ::= LBRACKET expList:e_list RBRACKET
                   {: RESULT = new Aexp(e_list, true); :};

                   /* {a,b,c,d,}*/
struct         ::= LBRACE keyValueList:kv_list RBRACE
                   {: RESULT = new Aexp(kv_list); :};


/*TODO: - make a class like expList to store key-value pairs, then procede similar to arrays.*/