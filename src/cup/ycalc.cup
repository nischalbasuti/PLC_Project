package src;
import java_cup.runtime.*;
import java.util.*;

terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, ASS;
terminal           RPAREN, LPAREN, RBRACKET, LBRACKET, RANGLE, LANGLE, COMMA;
terminal           IF, THEN, ELSE, WHILE,  DO, BEGIN,  END;
terminal           PRINT;
terminal           EQ, NOTEQ, LESSER, LESSEREQ, GREATER, GREATEREQ, AND, OR, NOT;
terminal Integer   INTDEF, FLOATDEF, BOOLEANDEF, CHARDEF, ARRAYDEF, FUNCDEF;
terminal Integer   INT;
terminal Float     FLOAT;
terminal Boolean   BOOLEAN;
terminal String    CHAR;
terminal MyArray ARRAY;
terminal String    ID;

non terminal Object             program;
non terminal Astat              statement, assignment, ifthen, print, while, statement_part, vardec;
non terminal Lstat              statement_list;
non terminal Aexp               expr, factor, term;
non terminal Aexp               boolExp, boolFactor, boolTerm, relation, notFactor;
non terminal Integer            type;

program         ::= statement_list:s
                    {: 
                        System.out.println("***Start of Program***");
                        s.execute(); 
                        System.out.println("***End of Program***");
                        SymbolTable.dump();
                    :};


statement_list  ::= statement_list:l statement_part:s
                    {: RESULT = new Lstat(l,s) ; :}
                |   statement_part:s
                    {: RESULT = new Lstat(s); :};

statement_part  ::= statement:s
                    {: RESULT = s; :}
                SEMI;

statement       ::= assignment:s
                    {: RESULT = s; :}
                | vardec:s
                    {: RESULT = s; :}
                | ifthen:s
                    {: RESULT = s; :}
                | print:s
                    {: RESULT = s; :}
                | while:s
                    {: RESULT = s; :}
                | BEGIN statement_list:s END
                    {: RESULT = Astat.block(s); :};

while           ::= WHILE boolExp:e DO statement:s
                    {: RESULT = Astat.whileloop(e,s); :};

print           ::= PRINT boolExp:e
                    {: RESULT = Astat.print(e); :};

ifthen          ::= IF boolExp:e THEN statement:s
                    {: RESULT = Astat.ifthen(e, s); :}
                |   IF boolExp:e THEN statement:s_if ELSE statement:s_else
                    {: RESULT = Astat.ifthenelse(e, s_if, s_else); :};

vardec          ::= type:t ID:i ASS boolExp:e
                    {: RESULT = Astat.declare(t, i, e); :}
                |  ARRAYDEF: a LANGLE type:t RANGLE ID:i ASS boolExp:e
                    {: RESULT = Astat.declare(a, t, i, e); :};

type            ::= INTDEF:i
                    {: RESULT = i; :}
                |  FLOATDEF:f
                    {: RESULT = f; :}
                |  BOOLEANDEF:b
                    {: RESULT = b; :}
                |  CHARDEF:c
                    {: RESULT = c; :};

assignment      ::= ID:i ASS boolExp:e
                    {: RESULT = Astat.assignment(i,e); :};

boolExp         ::= boolExp:e OR boolTerm:t
                    {: RESULT = new Aexp(new Args(e, t), sym.OR); :}
                |   boolTerm:t
                    {: RESULT = t; :};
boolTerm        ::= boolTerm:t AND notFactor:f
                    {: RESULT = new Aexp(new Args(t, f), sym.AND); :}
                |   notFactor:f
                    {: RESULT = f; :};
notFactor       ::= NOT boolFactor:b
                    {: RESULT = new Aexp(new Args(b), sym.NOT); :}
                |   boolFactor:f
                    {: RESULT = f; :};
boolFactor      ::= BOOLEAN:b
                    {: RESULT = new Aexp(b); :}
                |   relation:r
                    {: RESULT = r; :};
relation        ::= expr:e0 EQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.EQ);
                    :}
                    |expr:e0 NOTEQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.NOTEQ);
                    :}
                    |expr:e0 GREATEREQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.GREATEREQ);
                    :}
                    |expr:e0 GREATER expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.GREATER);
                    :}
                    |expr:e0 LESSEREQ expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.LESSEREQ);
                    :}
                    |expr:e0 LESSER expr:e1
                    {:
                        RESULT = new Aexp(new Args(e0,e1), sym.LESSER);
                    :}
                    | expr:e
                    {: RESULT = e; :};
expr            ::= expr:e PLUS term:t
                    {: RESULT = new Aexp(new Args(e,t), sym.PLUS); :}
                | expr:e MINUS term:t
                    {: RESULT = new Aexp(new Args(e,t), sym.MINUS); :}
                | term:t
                    {: RESULT = t; :};

term            ::= term:t TIMES factor:f
                    {: RESULT = new Aexp(new Args(t,f), sym.TIMES); :}
                | term:t DIVIDE factor:f
                    {: RESULT = new Aexp(new Args(t,f), sym.DIVIDE); :}
                | factor:f
                    {: RESULT = f; :};

factor          ::= LPAREN boolExp:e RPAREN
                    {: RESULT = e; :}
                | INT:i
                    {: RESULT = new Aexp(i); :}
                | FLOAT:f
                    {: RESULT = new Aexp(f); :}
                | CHAR:c
                    {: RESULT = new Aexp(c, false); :}
                | ARRAY:a
                    {: RESULT = new Aexp(a); :}
                | ID:i
                    {: RESULT = new Aexp(i, true); :};
